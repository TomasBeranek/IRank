#!/bin/bash

script=$(readlink -f "$0")
script_dir=$(dirname "$script")

output_dir="/home/tomas/Documents/diplomka/D2A-CPG"

infer_flags='--bufferoverrun --pulse'
infer_dir="/tmp/infer-out"
old_bitcode_files_list="${infer_dir}/old_bc_files.txt"
new_bitcode_files_list="${infer_dir}/new_bc_files.txt"
added_bitcode_files_list="${infer_dir}/added_bc_files.txt"
bc_combined="${infer_dir}/combined.bc"
slicing_info_file="${infer_dir}/slicing_info.csv"
bc_sliced="${infer_dir}/sliced.bc"
cpg_bin="${infer_dir}/sliced.cpg.bin.zip"
joern_script="${script_dir}/joern_script"
criteria_extraction_script="${script_dir}/slicing_criteria_extraction.py"
joern_cpg_bin="${infer_dir}/workspace/sliced.cpg.bin.zip/cpg.bin"

# colors
OK='\033[0;92m'
WARNING='\033[0;93m'
ERROR='\033[0;31m'
ENDC='\033[0m'

# navigate to Infer's dir
cd ${infer_dir}

# run infer's analysis phase to generate report.json
infer analyze --keep-going ${infer_flags} -o ${infer_dir}

# find all .bc files on the system and save them
find / -type f -name "*.bc" 2> /dev/null > ${new_bitcode_files_list}

# determine which files have been newly added and save them
grep -Fxvf ${old_bitcode_files_list} ${new_bitcode_files_list} > ${added_bitcode_files_list}

# link all .bc files into a single one
llvm-link $(< ${added_bitcode_files_list}) -o ${bc_combined}

# extract slicing criteria for all the bugs
python3 ${criteria_extraction_script} ${infer_dir}/report.json > ${slicing_info_file}
rc=$?

# if slicing_criteria_extraction.py exited with return code 0, it means that
# it successfully processed all the bugs (some may have been skipped) and created
# slicing_info.csv file
if [ ${rc} -eq 0 ]
then
	printf "${OK}SUCCESS${ENDC}: construction_phase: slicing criteria has been successfully extracted!\n"
else
	printf "${ERROR}ERROR${ENDC}: construction_phase: slicing_criteria_extraction.py has encountered an unrecoverable error!\n"
	exit 1
fi

# prepare output directory
mkdir ${output_dir} 2> /dev/null

# for each bug report (slicing criteria record)
while IFS=, read rc bug_id entry_function file fun line variable; do
	# slice the combined LLVM bitcode according to extracted slicing criteria
	# variables already contain required '&' sign
	llvm-slicer --entry=${entry_function} --sc="${file}#${fun}#${line}#${variable}" -o=${bc_sliced} ${bc_combined} 2> ${infer_dir}/llvm_slicer_stderr.txt

	# check if llvm-slicer succeeded
	if grep "No reachable slicing criteria:" ${infer_dir}/llvm_slicer_stderr.txt > /dev/null
	then
	  # llvm-slicer coudn't match extracted slicing criteria to bitcode
		printf "${WARNING}WARNING${ENDC}: construction_phase: skipping bug #${bug_id} because llvm-slicer couldn't match the extracted slicing criteria '${slicing_criteria}'!\n"
		continue
	fi

	# generate CPG
	llvm2cpg ${bc_sliced} --output=${cpg_bin} > ${infer_dir}/llvm2cpg_stdout.txt

	# check if llvm2cpg succeeded
	if grep "No bitcode files found." ${infer_dir}/llvm2cpg_stdout.txt > /dev/null
	then
	  # llvm-slicer coudn't match extracted slicing criteria to bitcode (this is not copy-paste error)
		printf "${WARNING}WARNING${ENDC}: construction_phase: skipping bug #${bug_id} because llvm2cpg failed to generate CPG!\n"
		continue
	fi

	# joern transforms generated CPG to CSV in Neo4j format
	# joern creates it's workspace in current dir --> Infer's dir
	joern --script ${joern_script}

	# check if joern succeeded
	# joern stores copy of imported CPG as workspace/sliced.cpg.bin.zip/cpg.bin
	if [ ! -f "${joern_cpg_bin}" ]; then
		# joern failed to import CPG generated by llvm2cpg e.g. the CPG file is missing
		# but when it is there, the cpg.bin is still created (although it may be faulty)
		printf "${WARNING}WARNING${ENDC}: construction_phase: skipping bug #${bug_id} because Joern failed to create internal representation of given CPG!\n"
		continue
	fi

	# export Joern's CPG to CSV
	joern-export --repr all --format neo4jcsv ${joern_cpg_bin}

	# check if joern-export succeeded
	if [ $? -ne 0 ]
	then
		# joern-export failed probably due to the faulty ${joern_cpg_bin} which
		# was caused by joern's importing which failed half-way
		printf "${WARNING}WARNING${ENDC}: construction_phase: skipping bug #${bug_id} because joern-export failed to create Neo4j CSV (Joern probably failed to import CPG)!\n"
		continue
	fi

	# create bug-specific directory
	mkdir ${output_dir}/${bug_id} 2> /dev/null

	# move all the bug-specific CSV files into it's directory
	# AST
	mv ${infer_dir}/out/edges_AST_* ${output_dir}/${bug_id} 2> /dev/null
	mv ${infer_dir}/out/edges_CONDITION_* ${output_dir}/${bug_id} 2> /dev/null
	mv ${infer_dir}/out/nodes_AST_NODE_* ${output_dir}/${bug_id} 2> /dev/null
	mv ${infer_dir}/out/nodes_BLOCK_* ${output_dir}/${bug_id} 2> /dev/null
	mv ${infer_dir}/out/nodes_CALL_* ${output_dir}/${bug_id} 2> /dev/null
	mv ${infer_dir}/out/nodes_CALL_REPR_* ${output_dir}/${bug_id} 2> /dev/null
	mv ${infer_dir}/out/nodes_CONTROL_STRUCTURE_* ${output_dir}/${bug_id} 2> /dev/null
	mv ${infer_dir}/out/nodes_EXPRESSION_* ${output_dir}/${bug_id} 2> /dev/null
	mv ${infer_dir}/out/nodes_FIELD_IDENTIFIER_* ${output_dir}/${bug_id} 2> /dev/null
	mv ${infer_dir}/out/nodes_IDENTIFIER_* ${output_dir}/${bug_id} 2> /dev/null
	mv ${infer_dir}/out/nodes_JUMP_LABEL_* ${output_dir}/${bug_id} 2> /dev/null
	mv ${infer_dir}/out/nodes_JUMP_TARGET_* ${output_dir}/${bug_id} 2> /dev/null
	mv ${infer_dir}/out/nodes_LITERAL_* ${output_dir}/${bug_id} 2> /dev/null
	mv ${infer_dir}/out/nodes_LOCAL_* ${output_dir}/${bug_id} 2> /dev/null
	mv ${infer_dir}/out/nodes_METHOD_REF_* ${output_dir}/${bug_id} 2> /dev/null
	mv ${infer_dir}/out/nodes_MODIFIER_* ${output_dir}/${bug_id} 2> /dev/null
	mv ${infer_dir}/out/nodes_RETURN_* ${output_dir}/${bug_id} 2> /dev/null
	mv ${infer_dir}/out/nodes_TYPE_REF_* ${output_dir}/${bug_id} 2> /dev/null
	mv ${infer_dir}/out/nodes_UNKNOWN_* ${output_dir}/${bug_id} 2> /dev/null

	# CallGraph - might be useful
	mv ${infer_dir}/out/edges_ARGUMENT_* ${output_dir}/${bug_id} 2> /dev/null
	mv ${infer_dir}/out/edges_CALL_* ${output_dir}/${bug_id} 2> /dev/null
	mv ${infer_dir}/out/edges_RECEIVER_* ${output_dir}/${bug_id} 2> /dev/null

	# CFG
	mv ${infer_dir}/out/edges_CFG_* ${output_dir}/${bug_id} 2> /dev/null
	mv ${infer_dir}/out/nodes_CFG_NODE_* ${output_dir}/${bug_id} 2> /dev/null # just in case

	# PDG
	mv ${infer_dir}/out/edges_CDG_* ${output_dir}/${bug_id} 2> /dev/null


	# success
	printf "${OK}SUCCESS${ENDC}: construction_phase: CPG for bug #${bug_id} was successfully constructed!\n"

done < ${slicing_info_file}

# TODO: for each subdirectory in ${output_dir} load CSV files into python objects
#				and filter out only useful information and save the object to .pickle.gz
