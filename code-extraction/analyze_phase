#!/bin/bash

script=$(readlink -f "$0")
script_dir=$(dirname "$script")

infer_flags='--bufferoverrun --pulse'
infer_dir="/tmp/infer-out"
old_bitcode_files_list="${infer_dir}/old_bc_files.txt"
new_bitcode_files_list="${infer_dir}/new_bc_files.txt"
added_bitcode_files_list="${infer_dir}/added_bc_files.txt"
bc_combined="${infer_dir}/combined.bc"
slicing_info_file="${infer_dir}/slicing_info.txt"
bc_sliced="${infer_dir}/sliced.bc"
cpg_bin="${infer_dir}/sliced.cpg.bin.zip"
joern_script="${script_dir}/joern_script"
criteria_extraction_script="${script_dir}/slicing_criteria_extraction.py"
joern_cpg_bin="${infer_dir}/workspace/sliced.cpg.bin.zip/cpg.bin"

# colors
OK='\033[0;92m'
WARNING='\033[0;93m'
ERROR='\033[0;31m'
ENDC='\033[0m'

# navigate to Infer's dir
cd ${infer_dir}

# run infer's analysis phase to generate report.json
infer analyze --keep-going ${infer_flags} -o ${infer_dir}

# find all .bc files on the system and save them
find / -type f -name "*.bc" 2> /dev/null > ${new_bitcode_files_list}

# determine which files have been newly added and save them
grep -Fxvf ${old_bitcode_files_list} ${new_bitcode_files_list} > ${added_bitcode_files_list}

# link all .bc files into a single one
llvm-link $(< ${added_bitcode_files_list}) -o ${bc_combined}

# make copy of report.json
cp ${infer_dir}/report.json ${infer_dir}/report-copy.json

# ID of current bug, corresponding to the order in the original report.json
bug_id=0

# for each bug report
while :
do
	failed_to_extract_slicing_info=false

  # extract slicing criteria for current bug and remove it from report-copy.json
	python3 ${criteria_extraction_script} ${infer_dir}/report-copy.json > ${slicing_info_file}
  rc=$?

  # if slicing_criteria_extraction.py exited with return code 0, it means that
  # it successfully processed current bug
  if [ ${rc} -eq 0 ]
  then
    printf "NOTE: analyze_phase: slicing criteria has been successfully extracted from bug #${bug_id}!\n"
  fi

  # if slicing_criteria_extraction.py exited with return code 1, it means that
  # it encountered an internal error
  if [ ${rc} -eq 1 ]
  then
    printf "${WARNING}WARNING${ENDC}: analyze_phase: skipping bug #${bug_id} because of internal error!\n"
		failed_to_extract_slicing_info=true
  fi

  # if slicing_criteria_extraction.py exited with return code 5, it means that
  # it tried to process an unsupported bug type
  if [ ${rc} -eq 5 ]
  then
    printf "${WARNING}WARNING${ENDC}: analyze_phase: skipping bug #${bug_id} because of unsupported type!\n"
		failed_to_extract_slicing_info=true
  fi

  # if slicing_criteria_extraction.py exited with return code 6, it means that
  # it processed all the bugs
  if [ ${rc} -eq 6 ]
  then
    printf "${OK}SUCCESS${ENDC}: analyze_phase: all the bugs have been processed!\n"
    break
  fi

	if ${failed_to_extract_slicing_info}
	then
		# for some reason it wasn't possible to generate CPG
		# TODO mark this information to report.json
		bug_id=$((bug_id+1))
		continue
	fi

	# if the code got here, then slicing criteria extraction succeeded
	# load slicing criteria from temporary file
	entry_function=$(head -1 ${slicing_info_file} | tail -1)
	slicing_file=$(head -2 ${slicing_info_file} | tail -1)
	slicing_line=$(head -3 ${slicing_info_file} | tail -1)
	slicing_variable=$(head -4 ${slicing_info_file} | tail -1)

	# slice the combined LLVM bitcode according to extracted slicing criteria
	llvm-slicer -entry ${entry_function} -sc "${slicing_file}##${slicing_line}#&${slicing_variable}" -o ${bc_sliced} ${bc_combined} 2> ${infer_dir}/llvm_slicer_stderr.txt

	# check if llvm-slicer succeeded
	if grep "No reachable slicing criteria:" ${infer_dir}/llvm_slicer_stderr.txt > /dev/null
	then
	  # llvm-slicer coudn't match extracted slicing criteria to bitcode
		printf "${WARNING}WARNING${ENDC}: analyze_phase: skipping bug #${bug_id} because llvm-slicer couldn't match the extracted slicing criteria \"${slicing_file}##${slicing_line}#&${slicing_variable}\"!\n"
		bug_id=$((bug_id+1))
		continue
	fi

	# generate CPG
	llvm2cpg ${bc_sliced} --output=${cpg_bin} > ${infer_dir}/llvm2cpg_stdout.txt

	# check if llvm2cpg succeeded
	if grep "No bitcode files found." ${infer_dir}/llvm2cpg_stdout.txt > /dev/null
	then
	  # llvm-slicer coudn't match extracted slicing criteria to bitcode
		printf "${WARNING}WARNING${ENDC}: analyze_phase: skipping bug #${bug_id} because llvm2cpg failed to generate CPG!\n"
		bug_id=$((bug_id+1))
		continue
	fi

	# joern transforms generated CPG to CSV in Neo4j format
	# joern creates it's workspace in current dir --> Infer's dir
	joern --script ${joern_script}

	# check if joern succeeded
	# joern stores copy of imported CPG as workspace/sliced.cpg.bin.zip/cpg.bin
	if [ ! -f "${joern_cpg_bin}" ]; then
		# joern failed to import CPG generated by llvm2cpg e.g. the CPG file is missing
		# but when it is there, the cpg.bin is still created (although it may be faulty)
		printf "${WARNING}WARNING${ENDC}: analyze_phase: skipping bug #${bug_id} because Joern failed to create internal representation of given CPG!\n"
		bug_id=$((bug_id+1))
		continue
	fi


	# TODO if joern-export fails it indicates that Joern failed to import given CPG
	#			 but still created it's (partial = faulty) internal representation



	# success
	printf "${OK}SUCCESS${ENDC}: analyze_phase: CPG for bug #${bug_id} was successfully constructed!\n"

	bug_id=$((bug_id+1))
done
