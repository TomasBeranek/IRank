# Basic CPG graph

# Následují informace o jednotlivých uzlech/hranách/parametrech a zda jsou zahrnuty do tohoto schématu. Pokud nejsou, je zde uveden důvod. Veškeré informace jsou získany z oficiální dokumentace Joern, která byla automaticky vygenerována z kódu - měla by tudíž být strukturně správně. Verze dokumentace 1.1 (https://cpg.joern.io/), verze Joern 1.1.1169 (Joern verze se shoduje s verzí dokumentace).


# MetaData Layer (https://cpg.joern.io/#schema-ref-metadata):
#   nodes_META_DATA_*

# Jedná se o jediný uzel typu META_DATA s ID:1 v každém CPG. Uzel obsahuje meta data týkající se vygenerování CPG. Uzel nebude použit kvůli:
#   1) veškeré informace jsou jíž známy (např. víme, že generujeme z LLVM),
#   2) všechny grafy obsahují uzel se stejnými informacemi (všechny grafy byly generovány stejně),
#   3) tyto informace nebudou modelu nijak užitečné (informace o genreování z jazyku LLVM by byla užitečná v případě, kdy by grafy byly generovány i z jiných jazyků, ale to zatím není plánováno - navíc by zřejmě jiné jazyky byly nejdříve převedeny do LLVM).


# FileSystem Layer (https://cpg.joern.io/#schema-ref-filesystem)
#   nodes_FILE_*
#   edges_SOURCE_FILE_*

# Uzly typu FILE představují zdrojové soubory nebo přeložené knihovny, ze kterých bylo vygenerováno CPG. Uzly typu NAMESPACE_BLOCK, METHOD, TYPE_DECL, COMMENT, LOCATION jsou výchozími uzly hrany typu SOURCE_FILE, která je spojuje s uzlem typu FILE, předtavujícím zdrojový soubor/knihovny ze které pocházejí. V případě použití D2A pipeline jsou všechny soubory s LLVM sloučeny do jediného pomocí llvm-link, aby z nich mohli později být vygenerovány CPG grafy. Díky to tak všechny uzly typu FILE (všech grafů) obsahují jako zdrojový soubour llvm-link. Informace o původních souborech tak Joern nebyl schopen získat. Tudíž uzly FILE a hrany SOURCE_FILE nejsou použity, protože nepřínášejí žadné nové informace.


# Namespace Layer (https://cpg.joern.io/#schema-ref-namespace)
#   nodes_NAMESPACE_*
#   nodes_NAMESPACE_BLOCK_*

# Jak již název napovídá tyto uzly představující namespace. Tyto uzly nejsou použity kvůli:
#   1) jazyk C jako takový nemá namespace (ani LLVM IR),
#   2) informace o namespace jsou tak doplněny jako '<global>' nebo 'llvm-link_global' - nepřídávají tak žádné užitečné informace.


# Method Layer (https://cpg.joern.io/#schema-ref-method)



# Type Layer (https://cpg.joern.io/#schema-ref-type)
#   nodes_MEMBER_*
#   nodes_TYPE_*
#   nodes_TYPE_ARGUMENT_*
#   nodes_TYPE_DECL_*
#   nodes_TYPE_PARAMETER_*
#   edges_ALIAS_OF_*
#   edges_BINDS_TO_*
#   edges_INHERITS_FROM_*

# Uzly TYPE_ARGUMENT, TYPE_PARAMETER a hrany BINDS_TO modelují parametrizovatelné datové typy - Java Generics a C++ templates. Takovéto typy se však v LLVM IR nevyskytují a grafy je tím pádem neobsahují. Rovněž hrany INHERITS_FROM nejsou v grafech přítomny. Type Layer se však dále zabývá modelováním typové hierarchie a aliasů. LLVM IR umožňuje jak strukturované datové typy tak aliasy (https://groups.seas.harvard.edu/courses/cs153/2019fa/lectures/Lec07-Datastructs.pdf). V jazyku C (na který se tato práce především zaměřuje) jsou taktéž přítomny strukturované datové typy (struct Name {...}) a aliasy (typedef OldName NewName). Nicméně při převodu z C do LLVM IR se aliasy odstraní (použijí se skutečná jména) a některé struktury se rozloží (né však všechny, ukázka zachovalé struct a odstraněného aliasu je vidět v <REPO>/model/schemes/test - je vhodné se podívat do human readable LLVM IR (llvm-dis test.bc –o test.ll)). Z tohoto důvodu je tak nutné zahrnout informaci o strukturách do výstupních grafů- Informacemi se myslí názvy struktur, jejich prvky a hierarchii. Pokud pro tento účel využijeme Type Layer zjednodušíme tím tak ostatní AST uzly - řada AST uzlu (u kterým to dává smysl např. LOCAL, LITERAL, IDENTIFIER, ...) obsahuje přidruženou informaci o svém datovém typu. Zároveň je takovýto uzel spojen hranou EVAL_TYPE s uzlem TYPE, vzniká zde tudíž redundantní informace o datových typech. A protože uzly TYPE potřebujeme kvůli informacím o strukturovaných datových typech, zachováme pouze je a informaci v AST uzlech odstraníme - tímto se AST uzly značně zjednodušší. Z TYPE uzlů budou odstraněny pouze ty, které nemají žadné příchozí hrany - jedná se o:
#  1) metadata pozůstatku po původních aliasech, ale jelikož se tyto aliasy v samotném kódu LLVM IR nikde nepoužívají, je tato informace zbytečná..
#  2) signatury funkcí - ty jsou taktéž redundantní informací, jelikož každý callsite je spojen s argumenty/parametry volané funkce (které jsou spojeny se svým datovým typem) a její návratovou hodnotou (která je taktéž spojena se svým datovým typem), signature je tak implicitně dána v grafu
# Dále odstraníme uzly TYPE_DECL, které oproti uzlu TYPE nepřidávají žádnou informaci při použití na LLVM IR. Pokud by však vstupem jazyk s parametrizovanými typy, tak uzel TYPE_DECL by představoval např. List[T] (samotný parametrizovatelný typ) a uzel TYPE by představoval List[Int] (instanci prametrizovatelného datového typu). TYPE_DECL uzly však spojují uzly TYPE s jejich složkami (pokud nějaké mají) - uzly typu MEMBER. Po odstranění některých TYPE_DECL uzlů je tak nutné opět připojit MEMBER uzly. Hrany ALIAS_OF propojují TYPE uzly (původní alias jména) se svým typem (uzel TYPE), protože však tyto "alias" uzly budou odstraněni nemá smysl zachovávat ALIAS_OF hrany. Ověření, že "alias" uzly a ALIAS_OF hrany jsou zbytečné lze udělat, že po odstranění všech TYPE uzlu, které nemají žádné vstupní EVAL_TYPE hrany (žádná část kódu tento typ nepoužívá), budou odstraněny taktéž všechny ALIAS_OF hrany.

node_sets {
  key: "TYPE"
  value {
    description: "This node represents a data type."

    features {
      key: "DATA_TYPE"
      value: {
        description: "Categorical data type label. 0 for structured types. If the type is an array, then DATA_TYPE stores its items type."
        dtype: DT_UINT8
      }
    }

    features {
      key: "PTR"
      value: {
        description: "Information whether this type is a pointer. 0 - not a pointer, > 0 how many times a pointer."
        dtype: DT_UINT8
      }
    }

    features {
      key: "LEN"
      value: {
        description: "Information whether this type is an array. 0 - not an array, > 0 array size."
        dtype: DT_UINT32
      }
    }
  }
}

# Uzly MEMBER jsou zakódovány jako obyčejné AST uzly, protože neobsahují žádnou užitečnou informaci - jedná se o latentní uzel propojující TYPE uzel (struktura) s jíným TYPE uzlem (datový typ struct složky, může být opět struct - takto se tvoří v grafu hierarchie). Jedinou potencionálně užitečnou informací je název podsložky v půdovdních C kódu - tetno název se však nikde v LLVM IR kódu nepoužívá a z toho důvodu je zahozen. Mohl by však nést jistý typ sémantické informace - např. pokud název složky je PID - lze z toho odvozovat jisté závěry o jeho hodnotě či použití.


# CFG Layer (https://cpg.joern.io/#schema-ref-cfg)
#   nodes_CFG_NODE_*
#   edges_CFG_*

# Uzly CFG_NODE jsou base class pro všechny CFG uzly, sám o sobě tak není v grafu přítomen. Hrany CFG jsou základní součástí CPG a jsou tak zahrnuty vev stupu tohoto modelu.

edge_sets {
  key: "CFG"
  value {
    description: "This edge indicates control flow from the source to the destination node."
    source: "TBD"
    target: "TBD"
  }
}


# Dominators Layer (https://cpg.joern.io/#schema-ref-dominators)
#   edges_DOMINATE_*
#   edges_POST_DOMINATE_*

# Tato vrstva obsahuje hrany, které tvoří dominator a post-dominator stromy pro všechny metody. Informace týkají se logiky dominátorů jsou převzaty z (https://www.cs.princeton.edu/courses/archive/spr04/cos598C/lectures/02-ControlFlow.pdf). Hrana DOMINATE/POST_DOMINATE propojuje CFG uzly. Hrana DOMINATE z uzlu A do uzlu B značí, že uzel A dominuje hranu B - to znamená, že každá cesta v CFG od počátečního uzlu do B musí obsahovat A. Obdobně hrana POST_DOMINATE z uzlu A do uzlu B značí, že uzel A post-dominuje hranu B - to znamená, že v každá cesta v CFG od uzlu B do exit uzlu musí obsahovat A. Tyto hrany mohou být užitečné pro explicitnější výjádření vztahů uzlů CFG, nicméně se jedná pouze o jednoduchou nádstavbu CFG a tak tyto hrany nebudou v datech základního modelu zahrnuty.


# PDG Layer (https://cpg.joern.io/#schema-ref-pdg)
#   edges_CDG_*
#   edges_REACHING_DEF_*

# CDG (Control Dependence Graph) hrana je součástí základního CPG, je tak součástí vstupu tohoto modelu. Hrany REACHING_DEF spolu s hranami CDG tvoří Program Dependence Graph (PDG) Layer. Hrana REACHING_DEF značí, že proměnná na zdrojovém uzlu dosáhné cílového uzlu, aniž by byla reassigned on the way. Hrana REACHING_DEF je velmi užitečnou informací, avšak těchto hran je příliš mnoho a mohli by tak model zahltit a velmi vysoce zvýšit výpočetní náročnost trénování. V této verzi tak hrany REACHING_DEF nebudou použity.

edge_sets {
  key: "CDG"
  value {
    description: "A CDG edge expresses that the destination node is control dependent on the source node."
    source: "TBD"
    target: "TBD"
  }
}


# Comment Layer (https://cpg.joern.io/#node-ref-comment)
#   nodes_COMMENT_*

# Tato vrstva reprezentuje komentáře v kódu. Při vytváření LLVM IR, projde zdrojový kód v jazyce C preprocessingem v překladači, který mimo jiné odstraní komentáře. Z tohoto důvodu tak nejsou žádné COMMENT uzly přítomny.


# Finding Layer (https://cpg.joern.io/#schema-ref-finding)
#   nodes_FINDING_*
#   nodes_KEY_VALUE_PAIR_*

# Tato vrstva umožňuje ukládání výsledků analýz (např. zranitelnosti, složitosti smyček, atp.) k různým uzlům. Joern však v základním nastavení tyto uzly neprodukuje a nejsou tak použity.


TagsAndLocation Layer (https://cpg.joern.io/#schema-ref-tagsandlocation)
#   nodes_LOCATION_*
#   nodes_TAG_*
#   nodes_TAG_NODE_PAIR_*
#   edges_TAGGED_BY_*

# Tato vrstva slouží jako jako podpora pro ukládání lokačních informací k uzlům pří custom analýzách. Narozdíl od Finding Layer se TagsAndLocation Layer používá spíše pro uchovávání meziproduktů analýz. V základních nastavení tyto uzly/hrany Joern neprodukuju - nebudou tak použity.



# Configuration Layer (https://cpg.joern.io/#schema-ref-configuration)
#   nodes_CONFIG_FILE_*

# Tato vrstva umožňuje vložení konfiguračních souborů přímo do CPG grafu.Tyto uzly nejsou použity kvůli:
#   1) v této diplomové práci pracujeme pouze se zdrojovým kódem a tak tyto uzly nejsou potřeba,
#   2) tyto uzly nejsou v základním nastavení Joern přítomny.





# Annotation Layer (https://cpg.joern.io/#schema-ref-annotation)
#   nodes_ANNOTATION_*
#   nodes_ANNOTATION_LITERAL_*
#   nodes_ANNOTATION_PARAMETER_*
#   nodes_ANNOTATION_PARAMETER_ASSIGN_*
#   nodes_ARRAY_INITIALIZER_*

# Tato vrstva přidává uzly reprezentující Java anotace. Jelikož se tato práce zabývá zejména jazykem C, tak žádné uzly těchto typů nejsou přítomny ve vygenerovaných grafech. Tudíž tato vrstva není použita.


# Base Layer (https://cpg.joern.io/#schema-ref-base)
#   nodes_DECLARATION_*
#   edges_REF_*

# Uzly typu DECLARATION slouží pouze jako base class nad kterou jsou dále definovány uzlu jako např. METHOD, METHOD_PARAMETER_IN, METHOD_PARAMETER_OUT, MEMBER a LOCAL. Uzly DECLARATION se tak samostatně nevyužívají. Hrana REF značí, že její source uzel je identifikátor, který přistupuje k destination uzlu. Příkladem co může hrana spojovat je např. identifikátor proměnné s danou lokální proměnnou nebo identifikátor typu s jeho deklarací, atp. Tato informace je užitečná v případě, když vstupem modelu jsou i identifikátory (což v našem připadě platí). Navíc hran REF není v porovnání s ostatními hranami tolik. Z těchto důvodů bude tato hrana v tomto modelu použita - rozšiřuje tak základní CPG o REF hranu.

edge_sets {
  key: "REF"
  value {
    description: "This edge indicates that the source node is an identifier that denotes access to the destination node. For example, an identifier may reference a local variable."
    source: "TBD"
    target: "TBD"
  }
}









# Ponechame pouze ORDER, ktery je spolecny vsem AST uzlum. TYPE_FULL_NAME nese
# informaci o typu bloku - jenze v jazyku C bloky nemaji typ, jedna se tak zrejme
# o typ posledniho statementu - Joern to tak zrejme dela genericky. Např. v jazyce
# Scala to pak dava smysl, protoze typ bloku == typ polsedniho vyrazu v bloku.
# Nicmene my pracujeme s C (LLVM IR) a tak budeme tuto informaci ingorovat. Dalsim
# jedinym uzitecnym sloupcem je ARGUMENT_INDEX, ktery ale souvisi s TYPE_FULL_NAME
# nasledujicim zpusobem: ARGUMENT_INDEX == 1, pokud blok urcity typ a ARGUMENT_INDEX
# == 1, pokud blok ma TYPE_FULL_NAME == 'ANY'. Neprinasi nam tudiz zadnou dalsi
# informaci. Zbyle sloupce maji stale stejnou hodnotu.


node_sets {
  key: "BLOCK"
  value {
    description: "This node represents a compound statement. In C it is { code... }."

    features {
      key: "ORDER"
      value: {
        description: "The nodes position among its siblings in AST, where the left most sibling has the position 0."
        dtype: DT_UINT8
      }
    }
  }
}


nodes_CALL_data.csv
nodes_CALL_header.csv
nodes_FIELD_IDENTIFIER_data.csv
nodes_FIELD_IDENTIFIER_header.csv
nodes_IDENTIFIER_data.csv
nodes_IDENTIFIER_header.csv
nodes_LITERAL_data.csv
nodes_LITERAL_header.csv
nodes_LOCAL_data.csv
nodes_LOCAL_header.csv
nodes_METHOD_REF_data.csv
nodes_METHOD_REF_header.csv
nodes_RETURN_data.csv
nodes_RETURN_header.csv
nodes_UNKNOWN_data.csv
nodes_UNKNOWN_header.csv

edges_AST_data.csv
edges_AST_header.csv
edges_CDG_data.csv
edges_CDG_header.csv
edges_CFG_data.csv
edges_CFG_header.csv
edges_RECEIVER_data.csv
edges_RECEIVER_header.csv
