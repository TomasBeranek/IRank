# Basic CPG graph

# Následují informace o jednotlivých uzlech/hranách/parametrech a zda jsou zahrnuty do tohoto schématu. Pokud nejsou, je zde uveden důvod. Veškeré informace jsou získany z oficiální dokumentace Joern, která byla automaticky vygenerována z kódu - měla by tudíž být strukturně správně. Verze dokumentace 1.1 (https://cpg.joern.io/), verze Joern 1.1.1169 (Joern verze se shoduje s verzí dokumentace).


# MetaData Layer (https://cpg.joern.io/#schema-ref-metadata):
#   nodes_META_DATA_*

# Jedná se o jediný uzel typu META_DATA s ID:1 v každém CPG. Uzel obsahuje meta data týkající se vygenerování CPG. Uzel nebude použit kvůli:
#   1) veškeré informace jsou jíž známy (např. víme, že generujeme z LLVM),
#   2) všechny grafy obsahují uzel se stejnými informacemi (všechny grafy byly generovány stejně),
#   3) tyto informace nebudou modelu nijak užitečné (informace o genreování z jazyku LLVM by byla užitečná v případě, kdy by grafy byly generovány i z jiných jazyků, ale to zatím není plánováno - navíc by zřejmě jiné jazyky byly nejdříve převedeny do LLVM).


# FileSystem Layer (https://cpg.joern.io/#schema-ref-filesystem)
#   nodes_FILE_*
#   edges_SOURCE_FILE_*

# Uzly typu FILE představují zdrojové soubory nebo přeložené knihovny, ze kterých bylo vygenerováno CPG. Uzly typu NAMESPACE_BLOCK, METHOD, TYPE_DECL, COMMENT, LOCATION jsou výchozími uzly hrany typu SOURCE_FILE, která je spojuje s uzlem typu FILE, předtavujícím zdrojový soubor/knihovny ze které pocházejí. V případě použití D2A pipeline jsou všechny soubory s LLVM sloučeny do jediného pomocí llvm-link, aby z nich mohli později být vygenerovány CPG grafy. Díky to tak všechny uzly typu FILE (všech grafů) obsahují jako zdrojový soubour llvm-link. Informace o původních souborech tak Joern nebyl schopen získat. Tudíž uzly FILE a hrany SOURCE_FILE nejsou použity, protože nepřínášejí žadné nové informace.


# Namespace Layer (https://cpg.joern.io/#schema-ref-namespace)
#   nodes_NAMESPACE_*
#   nodes_NAMESPACE_BLOCK_*

# Jak již název napovídá tyto uzly představující namespace. Tyto uzly nejsou použity kvůli:
#   1) jazyk C jako takový nemá namespace (ani LLVM IR),
#   2) informace o namespace jsou tak doplněny jako '<global>' nebo 'llvm-link_global' - nepřídávají tak žádné užitečné informace.


# Method Layer (https://cpg.joern.io/#schema-ref-method)
#   nodes_METHOD_*
#   nodes_METHOD_PARAMETER_IN_*
#   nodes_METHOD_PARAMETER_OUT_*
#   nodes_METHOD_RETURN_*

Method Layer explicitně popisuje informace o každé funkci. Uzel METHOD představuje samotnout funkci - obsahuje její jméno, signaturu, soubor původu nebo informaci, zda k ní máme i zdrojový kód (sloupec IS_EXTERNAL). METHOD uzly také slouží jako cílový uzel CALL hrany, který propojuje místo volání funkce (CALL uzel) se samotnou funkci (METHOD uzel). Na každý METHOD uzel jsou pak připojeny (pomocí AST hran) METHOD_PARAMETER_IN a METHOD_PARAMETER_OUT uzly, které slouží jako propojení METHOD uzlu a parametru dané funkce. Rozdíl mezi METHOD_PARAMETER_IN a METHOD_PARAMETER_OUT je pouze u jazyků, kde se pracuje s dynamickými typy - což není případ u LLVM IR. Z toho důvodu jsou odtraněny veškeré METHOD_PARAMETER_OUT uzly. Na METHOD uzel je také připojen (pomocí AST) uezl METHOD_RETURN, které přestavuje abstrakci návratové hodnoty. Na tento uzel je pomocí CFG hrany připojen RETURN uzel (nebo více, pokud má funkce více příkazů 'ret' v LLVM IR - což se ale moc nestává, protože se typicky používá návratová proměnná, která se přepíše - tam kde byl původní 'return' v C a pak na konci funkce je tato návratová hodnota vrácena). Uzly METHOD, METHOD_PARAMETER_IN a METHOD_RETURN jsou všechny použity, protože:
#   1) dohromady je jich velmi málo - pro každou funkci typicky 1x METHOD, 1x RETURN a Nx METHOD_PARAMETER_IN, kde N je počet parametrů funkce, taktéž k těmto uzlům vede poměrné málo hran,
#   2) slouží jako velmi pěkné a explicitní propojení mezi místem volání a volanou funkcí (vhodně se předávájí argumenty parametrům a hodnota return výrazu volání funkce)
# Důležitou zmínkou je taktéž, že METHOD_PARAMETER_IN může být VARIADIC (sloupec IS_VARIADIC) - tzn., že představuje libovolný počet parametrů, v C je tato konstrukce značena jako '...' např u 'int printf(const char *format, ...)'. Zároveň je nutné uvažovat, že každá operace - jako např. sčítání, odčítání, dereference atp. je v modelovánojako volání funkce - viz. model/scheme/examples/arg-passing/.


# Type Layer (https://cpg.joern.io/#schema-ref-type)
#   nodes_MEMBER_*
#   nodes_TYPE_*
#   nodes_TYPE_ARGUMENT_*
#   nodes_TYPE_DECL_*
#   nodes_TYPE_PARAMETER_*
#   edges_ALIAS_OF_*
#   edges_BINDS_TO_*
#   edges_INHERITS_FROM_*

# Uzly TYPE_ARGUMENT, TYPE_PARAMETER a hrany BINDS_TO modelují parametrizovatelné datové typy - Java Generics a C++ templates. Takovéto typy se však v LLVM IR nevyskytují a grafy je tím pádem neobsahují. Rovněž hrany INHERITS_FROM nejsou v grafech přítomny. Type Layer se však dále zabývá modelováním typové hierarchie a aliasů. LLVM IR umožňuje jak strukturované datové typy tak aliasy (https://groups.seas.harvard.edu/courses/cs153/2019fa/lectures/Lec07-Datastructs.pdf). V jazyku C (na který se tato práce především zaměřuje) jsou taktéž přítomny strukturované datové typy (struct Name {...}) a aliasy (typedef OldName NewName). Nicméně při převodu z C do LLVM IR se aliasy odstraní (použijí se skutečná jména) a některé struktury se rozloží (né však všechny, ukázka zachovalé struct a odstraněného aliasu je vidět v <REPO>/model/schemes/test - je vhodné se podívat do human readable LLVM IR (llvm-dis test.bc –o test.ll)). Z tohoto důvodu je tak nutné zahrnout informaci o strukturách do výstupních grafů- Informacemi se myslí názvy struktur, jejich prvky a hierarchii. Pokud pro tento účel využijeme Type Layer zjednodušíme tím tak ostatní AST uzly - řada AST uzlu (u kterým to dává smysl např. LOCAL, LITERAL, IDENTIFIER, ...) obsahuje přidruženou informaci o svém datovém typu. Zároveň je takovýto uzel spojen hranou EVAL_TYPE s uzlem TYPE, vzniká zde tudíž redundantní informace o datových typech. A protože uzly TYPE potřebujeme kvůli informacím o strukturovaných datových typech, zachováme pouze je a informaci v AST uzlech odstraníme - tímto se AST uzly značně zjednodušší. Z TYPE uzlů budou odstraněny pouze ty, které nemají žadné příchozí hrany - jedná se o:
#  1) metadata pozůstatku po původních aliasech, ale jelikož se tyto aliasy v samotném kódu LLVM IR nikde nepoužívají, je tato informace zbytečná..
#  2) signatury funkcí - ty jsou taktéž redundantní informací, jelikož každý callsite je spojen s argumenty/parametry volané funkce (které jsou spojeny se svým datovým typem) a její návratovou hodnotou (která je taktéž spojena se svým datovým typem), signature je tak implicitně dána v grafu
# Dále odstraníme uzly TYPE_DECL, které oproti uzlu TYPE nepřidávají žádnou informaci při použití na LLVM IR. Pokud by však vstupem jazyk s parametrizovanými typy, tak uzel TYPE_DECL by představoval např. List[T] (samotný parametrizovatelný typ) a uzel TYPE by představoval List[Int] (instanci prametrizovatelného datového typu). TYPE_DECL uzly však spojují uzly TYPE s jejich složkami (pokud nějaké mají) - uzly typu MEMBER. Po odstranění některých TYPE_DECL uzlů je tak nutné opět připojit MEMBER uzly. Hrany ALIAS_OF propojují TYPE uzly (původní alias jména) se svým typem (uzel TYPE), protože však tyto "alias" uzly budou odstraněni nemá smysl zachovávat ALIAS_OF hrany. Ověření, že "alias" uzly a ALIAS_OF hrany jsou zbytečné lze udělat, že po odstranění všech TYPE uzlu, které nemají žádné vstupní EVAL_TYPE hrany (žádná část kódu tento typ nepoužívá), budou odstraněny taktéž všechny ALIAS_OF hrany.

node_sets {
  key: "TYPE"
  value {
    description: "This node represents a data type."

    features {
      key: "DATA_TYPE"
      value: {
        description: "Categorical data type label. 0 for structured types. If the type is an array, then DATA_TYPE stores its items type."
        dtype: DT_UINT8
      }
    }

    features {
      key: "PTR"
      value: {
        description: "Information whether this type is a pointer. 0 - not a pointer, > 0 how many times a pointer."
        dtype: DT_UINT8
      }
    }

    features {
      key: "LEN"
      value: {
        description: "Information whether this type is an array. 0 - not an array, > 0 array size."
        dtype: DT_UINT32
      }
    }
  }
}

# Uzly MEMBER jsou zakódovány jako obyčejné AST uzly, protože neobsahují žádnou užitečnou informaci - jedná se o latentní uzel propojující TYPE uzel (struktura) s jíným TYPE uzlem (datový typ struct složky, může být opět struct - takto se tvoří v grafu hierarchie). Jedinou potencionálně užitečnou informací je název podsložky v půdovdních C kódu - tetno název se však nikde v LLVM IR kódu nepoužívá a z toho důvodu je zahozen. Mohl by však nést jistý typ sémantické informace - např. pokud název složky je PID - lze z toho odvozovat jisté závěry o jeho hodnotě či použití.


# AST Layer (https://cpg.joern.io/#schema-ref-ast)
#   nodes_AST_NODE_*
#   nodes_BLOCK_*
#   nodes_CALL_*
#   nodes_CALL_REPR_*
#   nodes_CONTROL_STRUCTURE_*
#   nodes_EXPRESSION_*
#   nodes_FIELD_IDENTIFIER_*
#   nodes_IDENTIFIER_*
#   nodes_JUMP_LABEL_*
#   nodes_JUMP_TARGET_*
#   nodes_LITERAL_*
#   nodes_LOCAL_*
#   nodes_METHOD_REF_*
#   nodes_MODIFIER_*
#   nodes_RETURN_*
#   nodes_TYPE_REF_*
#   nodes_UNKNOWN_*
#   edges_AST_*
#   edges_CONDITION_*

# AST Layer vytváří abstraktní syntaktické stromy ze vstupního kódu. Všechny uzly mají base class AST_NODE a jsou proppojeny AST hranami. Uzly AST_NODE jsou pouze base class, která definuje vlastnosti všechny AST uzlů. AST_NODE uzly tak nejsou přítomny v grafech. Uzly BLOCK představují compound statement - v C, Java, C++ i LLVM IR se to značí pomocí '{}'. BLOCK uzly jako takové nepřínáší žádnou užitečnou informaci, ale vhodně shlukují jiné typy uzlů v AST stromu - např. BLOCK uzel představující tělo funkce má jako své child uzly top-level příkazy v dané funkci. Z toho důvodu jsou BLOCK uzly ponechány pro předávání informací při výpočtu GNN. CALL uzel představuje volání funkce/metody/procedury. Spolu s vrstvami Type a CallGraph tvoří velmi duležité propojení místa volání s volanou funkcí (callee). CALL uzly jsou tak zachovány. CALL_REPR jsou pouze base class pro CALL uzly a v grafu se tak nevyskytuje. Uzly CONTROL_STRUCTURE, JUMP_LABEL, JUMP_TARGET představují popořadě struktury pro ovlivňování toku řízení, názvy návěští skoků a místa, kam se skáče. V LLVM IR nejsou přítomny žádné vysokoúrovňové control structures - pouze podmíněné a nepodmíněné skoky. Ovšem i ty nejsou příitomny jako uzly, ale jsou reprezentovány pomocí PDG a CFG hran - viz obrázky v model/schemes/examples/. Žádné z uzlů  CONTROL_STRUCTURE, JUMP_LABEL, JUMP_TARGET, tak nejsou v grafech přítomny. EXPRESSION je opět pouze base class a tak tyto uzly jako takové nejsou přítomny. Uzly FIELD_IDENTIFIER reprezentují pole, LLVM IR podporuje datový typ pole a proto jsou uzly ponechány. Uzly IDENTIFIER reprezentují proměnné, jsou proto ponechány. Uzly LITERAL představují konstanty různých datových typů, hodnoty těchto uzlů budou uloženy jako speciální uzly (viz. další kapitola). Uzly LOCAL představují lokální proměnné, informace o tom, zda proměnná je lokální či nikoliv může být užitečná. A protože těchto uzlů není mnoho, budou ponechány. Uzly METHOD_REF představují reference na metody/funkce/procedury při použití jako argumenty při volání. U těchto uzlů není potřeba si uchovávat jméno funkcí, které představují, protože jsou REF hranou propojeny s uzly METHOD. Uzly MODIFIER přestavují modifikátory (language dependant) jako např. static/private/public. V grafech vygenerovaných z LLVM IR se tyto uzly nevyskytují. Uzly RETURN představují 'return' příkazy funkcí/metod/procedur. Tyto uzly jsou nezbytné pro zpětné předávání informací z funkcí k jejich callsite. Uzly TYPE_REF představují reference typů/tříd. Tyto uzly se v grafech nevyskytují. Uzly UNKNOWN představují zbylé AST uzly pro které se nehodí žadný jiný typ. Tyto uzly se v grafu ponechávají zejména pro zachování hran v grafu. Hrany AST jsou základem CPG grafu a jsou tak zachovány. Hrany CONDITION propojují kontrolní struktury s jejich řídícími podmínkami. Jelikož však řídící struktury v grafu (v případě LLVM IR) nemají své uzly, tak se tyto hrany v grafu nevyskytují.




# CallGraph Layer (https://cpg.joern.io/#schema-ref-callgraph)
#   edges_ARGUMENT_*
#   edges_CALL_*
#   edges_RECEIVER_*

# CallGraph Layer modeluje volání funkcí. Hrany ARGUMENT propojují uzly CALL se svými argumenty (uzly typu EXPRESSION) a také uzly RETURN s hodnotou, kterou vracejí (opět uzel typu EXPRESSION). Tyto uzly jsou užitečné, protože v rámci AST umožňují odližit argumenty funkcí/návrtové hodnoty od ostatních ostaních - jsou explicitnější a zároveň je jich poměrně málo. Hrany CALL propojují CALL uzly a METHOD uzly, jsou tak nezbytné pro dobrou propagaci informace mezi voláním funkce a danou funkcí - je nutné je tak ponechat. Hrany RECEIVER slouží k propojení CALL uzlu a objektu, nad kterým je metoda volána. Tyto hrany jsou užitečné v případě OOP, což ale LLVM IR není. RECEIVER hrany jsou tak vynechány.

edge_sets {
  key: "ARGUMENT"
  value {
    description: "Argument edges connect call sites to their arguments as well as `RETURN` nodes to the expressions that return."
    source: "TBD"
    target: "TBD"
  }

edge_sets {
  key: "CALL"
  value {
    description: "This edge connects call sites to the method they invoke."
    source: "TBD"
    target: "TBD"
  }


# CFG Layer (https://cpg.joern.io/#schema-ref-cfg)
#   nodes_CFG_NODE_*
#   edges_CFG_*

# Uzly CFG_NODE jsou base class pro všechny CFG uzly, sám o sobě tak není v grafu přítomen. Hrany CFG jsou základní součástí CPG a jsou tak zahrnuty vev stupu tohoto modelu.

edge_sets {
  key: "CFG"
  value {
    description: "This edge indicates control flow from the source to the destination node."
    source: "TBD"
    target: "TBD"
  }
}


# Dominators Layer (https://cpg.joern.io/#schema-ref-dominators)
#   edges_DOMINATE_*
#   edges_POST_DOMINATE_*

# Tato vrstva obsahuje hrany, které tvoří dominator a post-dominator stromy pro všechny metody. Informace týkají se logiky dominátorů jsou převzaty z (https://www.cs.princeton.edu/courses/archive/spr04/cos598C/lectures/02-ControlFlow.pdf). Hrana DOMINATE/POST_DOMINATE propojuje CFG uzly. Hrana DOMINATE z uzlu A do uzlu B značí, že uzel A dominuje hranu B - to znamená, že každá cesta v CFG od počátečního uzlu do B musí obsahovat A. Obdobně hrana POST_DOMINATE z uzlu A do uzlu B značí, že uzel A post-dominuje hranu B - to znamená, že v každá cesta v CFG od uzlu B do exit uzlu musí obsahovat A. Tyto hrany mohou být užitečné pro explicitnější výjádření vztahů uzlů CFG, nicméně se jedná pouze o jednoduchou nádstavbu CFG a tak tyto hrany nebudou v datech základního modelu zahrnuty.


# PDG Layer (https://cpg.joern.io/#schema-ref-pdg)
#   edges_CDG_*
#   edges_REACHING_DEF_*

# CDG (Control Dependence Graph) hrana je součástí základního CPG, je tak součástí vstupu tohoto modelu. Hrany REACHING_DEF spolu s hranami CDG tvoří Program Dependence Graph (PDG) Layer. Hrana REACHING_DEF značí, že proměnná na zdrojovém uzlu dosáhné cílového uzlu, aniž by byla reassigned on the way. Hrana REACHING_DEF je velmi užitečnou informací, avšak těchto hran je příliš mnoho a mohli by tak model zahltit a velmi vysoce zvýšit výpočetní náročnost trénování. V této verzi tak hrany REACHING_DEF nebudou použity.

edge_sets {
  key: "CDG"
  value {
    description: "A CDG edge expresses that the destination node is control dependent on the source node."
    source: "TBD"
    target: "TBD"
  }
}


# Comment Layer (https://cpg.joern.io/#node-ref-comment)
#   nodes_COMMENT_*

# Tato vrstva reprezentuje komentáře v kódu. Při vytváření LLVM IR, projde zdrojový kód v jazyce C preprocessingem v překladači, který mimo jiné odstraní komentáře. Z tohoto důvodu tak nejsou žádné COMMENT uzly přítomny.


# Finding Layer (https://cpg.joern.io/#schema-ref-finding)
#   nodes_FINDING_*
#   nodes_KEY_VALUE_PAIR_*

# Tato vrstva umožňuje ukládání výsledků analýz (např. zranitelnosti, složitosti smyček, atp.) k různým uzlům. Joern však v základním nastavení tyto uzly neprodukuje a nejsou tak použity.


# Shortcuts Layer (https://cpg.joern.io/#schema-ref-shortcuts)
#   edges_CONTAINS_*
#   edges_EVAL_TYPE_*
#   edges_PARAMETER_LINK_*

# Hrany CONTAINS spojují METHOD uzly se všemi uzly, které k dané metodě patří. I když se jedná poměrně užetečnou informaci a takové hrany by mohli sloužit k dobré propagaci informace uvnitř funkcí, tak je počet těchto hran příliš velký. Z tohoto důvodu jsou hrany CONTAINS vynechány a šíření informace tak zůstává na dalších hranách. Hrany EVAL_TYPE propojují AST uzly (u kterých má smysl uvažovat o datovém typu) s uzly TYPE. Těchto hran je taktéž velké množství (ikdyž o něco méně), ale TYPE uzly jsou v tomto modelu zachovány (a informace o datových typech je z AST uzlů odstraněna), kvůli modelování hierarchii datových typů. Je tak nutné zachovat alespoň toto spojení mezi AST uzly jejich typy. Hrany PARAMETER_LINK propojují pouze uzly METHOD_PARAMETER_IN a METHOD_PARAMETER_OUT, ale jelikož jsou všechny uzly METHOD_PARAMETER_OUT odstraněny, nemá smysl tyto hrany ponechávát.

edge_sets {
  key: "EVAL_TYPE"
  value {
    description: "This edge connects a node to its evaluation type."
    source: "TBD"
    target: "TBD"
  }
}


TagsAndLocation Layer (https://cpg.joern.io/#schema-ref-tagsandlocation)
#   nodes_LOCATION_*
#   nodes_TAG_*
#   nodes_TAG_NODE_PAIR_*
#   edges_TAGGED_BY_*

# Tato vrstva slouží jako jako podpora pro ukládání lokačních informací k uzlům pří custom analýzách. Narozdíl od Finding Layer se TagsAndLocation Layer používá spíše pro uchovávání meziproduktů analýz. V základních nastavení tyto uzly/hrany Joern neprodukuju - nebudou tak použity.


# Configuration Layer (https://cpg.joern.io/#schema-ref-configuration)
#   nodes_CONFIG_FILE_*

# Tato vrstva umožňuje vložení konfiguračních souborů přímo do CPG grafu.Tyto uzly nejsou použity kvůli:
#   1) v této diplomové práci pracujeme pouze se zdrojovým kódem a tak tyto uzly nejsou potřeba,
#   2) tyto uzly nejsou v základním nastavení Joern přítomny.


# Binding Layer (https://cpg.joern.io/#schema-ref-binding)
#   nodes_BINDING_*
#   edges_BINDS_*

# BINDING uzel představuje pár - jméno funkce a její signatura. Hrana BINDS, pak spojuje tento uzel s DECL_TYPE uzel, který představuje danou signaturu. Nicméně u tohoto modelu využíváme k získání signatury graf jako takový (RETURN uzel je napojen na TYPE uzel, METHOD_PARAMETER_IN je napojen na TYPE uzel), není tudíž zapotřebí explicitně signaturu ukládat. Navíc jsou všechny DECL_TYPE uzly odstraněni z podobného důvodu. Nepouživá se tak zde ani BINDING uzly, ani BINDS hrany.


# Annotation Layer (https://cpg.joern.io/#schema-ref-annotation)
#   nodes_ANNOTATION_*
#   nodes_ANNOTATION_LITERAL_*
#   nodes_ANNOTATION_PARAMETER_*
#   nodes_ANNOTATION_PARAMETER_ASSIGN_*
#   nodes_ARRAY_INITIALIZER_*

# Tato vrstva přidává uzly reprezentující Java anotace. Jelikož se tato práce zabývá zejména jazykem C, tak žádné uzly těchto typů nejsou přítomny ve vygenerovaných grafech. Tudíž tato vrstva není použita.


# Base Layer (https://cpg.joern.io/#schema-ref-base)
#   nodes_DECLARATION_*
#   edges_REF_*

# Uzly typu DECLARATION slouží pouze jako base class nad kterou jsou dále definovány uzlu jako např. METHOD, METHOD_PARAMETER_IN, METHOD_PARAMETER_OUT, MEMBER a LOCAL. Uzly DECLARATION se tak samostatně nevyužívají. Hrana REF značí, že její source uzel je identifikátor, který přistupuje k destination uzlu. Příkladem co může hrana spojovat je např. identifikátor proměnné s danou lokální proměnnou nebo identifikátor typu s jeho deklarací, atp. Tato informace je užitečná v případě, když vstupem modelu jsou i identifikátory (což v našem připadě platí). Navíc hran REF není v porovnání s ostatními hranami tolik. Z těchto důvodů bude tato hrana v tomto modelu použita - rozšiřuje tak základní CPG o REF hranu.

edge_sets {
  key: "REF"
  value {
    description: "This edge indicates that the source node is an identifier that denotes access to the destination node. For example, an identifier may reference a local variable."
    source: "TBD"
    target: "TBD"
  }
}









# Ponechame pouze ORDER, ktery je spolecny vsem AST uzlum. TYPE_FULL_NAME nese
# informaci o typu bloku - jenze v jazyku C bloky nemaji typ, jedna se tak zrejme
# o typ posledniho statementu - Joern to tak zrejme dela genericky. Např. v jazyce
# Scala to pak dava smysl, protoze typ bloku == typ polsedniho vyrazu v bloku.
# Nicmene my pracujeme s C (LLVM IR) a tak budeme tuto informaci ingorovat. Dalsim
# jedinym uzitecnym sloupcem je ARGUMENT_INDEX, ktery ale souvisi s TYPE_FULL_NAME
# nasledujicim zpusobem: ARGUMENT_INDEX == 1, pokud blok urcity typ a ARGUMENT_INDEX
# == 1, pokud blok ma TYPE_FULL_NAME == 'ANY'. Neprinasi nam tudiz zadnou dalsi
# informaci. Zbyle sloupce maji stale stejnou hodnotu.


node_sets {
  key: "BLOCK"
  value {
    description: "This node represents a compound statement. In C it is { code... }."

    features {
      key: "ORDER"
      value: {
        description: "The nodes position among its siblings in AST, where the left most sibling has the position 0."
        dtype: DT_UINT8
      }
    }
  }
}
